name: Transcribe MP3 on Push

on:
  push:
    branches:
      - 'process-*'
  workflow_dispatch:
    inputs:
      batch_number:
        description: 'Batch number to process (starting from 1)'
        required: false
        default: '256'

permissions:
  contents: write

jobs:
  transcribe-on-push:
    if: github.event_name == 'push'
    runs-on: runner
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          ref: ${{ github.ref }}

      - name: Process MP3 with Whisper JAX
        run: |
          source /home/junfan/test/venv/bin/activate
          export HIP_VISIBLE_DEVICES=0,1,2,3,4,5,6,7
          python3 << EOF
          from transformers import pipeline
          asr_pipeline = pipeline("automatic-speech-recognition", model="openai/whisper-large-v2", device=0)
          result = asr_pipeline("output.mp3", return_timestamps=True)

          def format_timestamp(seconds):
              hours = int(seconds // 3600)
              minutes = int((seconds % 3600) // 60)
              seconds = seconds % 60
              milliseconds = int((seconds - int(seconds)) * 1000)
              return f"{hours:02}:{minutes:02}:{int(seconds):02},{milliseconds:03}"

          with open('transcript.srt', 'w', encoding='utf-8') as f:
              for i, segment in enumerate(result['chunks'], start=1):
                  start = segment['timestamp'][0]
                  end = segment['timestamp'][1]
                  text = segment['text'].strip()
                  f.write(f"{i}\n{format_timestamp(start)} --> {format_timestamp(end)}\n{text}\n\n")

          with open('transcript.txt', 'w', encoding='utf-8') as f:
              for segment in result['chunks']:
                  start = segment['timestamp'][0]
                  end = segment['timestamp'][1]
                  text = segment['text'].strip()
                  f.write(f"[{format_timestamp(start)} -> {format_timestamp(end)}] {text}\n")

          print("Transcription completed and saved.")
          EOF

      - name: Commit Transcript
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'
          git remote set-url origin https://${{ github.actor }}:${{ env.GH_TOKEN }}@github.com/${{ github.repository }}
          git add transcript.srt transcript.txt
          git commit -m 'Add transcription files'
          git push origin ${{ github.ref }}

  find-branches:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      total_batches: ${{ steps.calculate-batches.outputs.total_batches }}
      batch_branches: ${{ steps.calculate-batches.outputs.batch_branches }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: List branches
        id: list-branches
        run: |
          git fetch --all
          BRANCHES=$(git ls-remote --heads origin "process-*" | awk '{print $2}' | sed 's|refs/heads/||')
          echo "Found branches:"
          echo "$BRANCHES"
          # Clear or create the file to avoid appending to old data
          > branches_to_process.txt
          for BRANCH in $BRANCHES; do
            echo "Checking branch $BRANCH"
            if ! git ls-tree -r --name-only origin/$BRANCH | grep -qE 'transcript\.txt|transcript\.srt'; then
              echo "Branch $BRANCH does not have transcript files."
              echo "$BRANCH" >> branches_to_process.txt
            else
              echo "Branch $BRANCH already has transcript files."
            fi
          done
          echo "Branches to process:"
          cat branches_to_process.txt

      - name: Calculate Batches
        id: calculate-batches
        run: |
          BATCH_SIZE=256
          BATCH_NUMBER=${{ github.event.inputs.batch_number }}
          if [ -z "$BATCH_NUMBER" ]; then
            BATCH_NUMBER=1
          fi
          echo "Processing batch number: $BATCH_NUMBER"
          TOTAL_BRANCHES=$(wc -l < branches_to_process.txt)
          TOTAL_BATCHES=$(( (TOTAL_BRANCHES + BATCH_SIZE - 1) / BATCH_SIZE ))
          echo "Total batches: $TOTAL_BATCHES"
          START_INDEX=$(( (BATCH_NUMBER - 1) * BATCH_SIZE + 1 ))
          END_INDEX=$(( BATCH_NUMBER * BATCH_SIZE ))
          if [ $END_INDEX -gt $TOTAL_BRANCHES ]; then
            END_INDEX=$TOTAL_BRANCHES
          fi
          echo "Processing branches from $START_INDEX to $END_INDEX"
          
          # Extract the branches for this batch and convert to JSON format
          BATCH_BRANCHES=()
          while IFS= read -r branch; do
            BATCH_BRANCHES+=("\"$branch\"")
          done < <(sed -n "${START_INDEX},${END_INDEX}p" branches_to_process.txt)
          
          # Create JSON array and output to GitHub
          BATCH_BRANCHES_JSON="[${BATCH_BRANCHES[*]}]"
          echo "batch_branches=$BATCH_BRANCHES_JSON" >> $GITHUB_OUTPUT
          echo "total_batches=$TOTAL_BATCHES" >> $GITHUB_OUTPUT
          
          echo "Batch branches JSON: $BATCH_BRANCHES_JSON"

  transcribe-on-dispatch:
    if: github.event_name == 'workflow_dispatch' && needs.find-branches.outputs.batch_branches != '[]'
    needs: [find-branches]
    runs-on: runner
    strategy:
      matrix:
        branch: ${{ fromJson(needs.find-branches.outputs.batch_branches) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          ref: ${{ matrix.branch }}

      - name: Process MP3 with Whisper JAX
        run: |
          source /home/junfan/test/venv/bin/activate
          export HIP_VISIBLE_DEVICES=0,1,2,3,4,5,6,7
          python3 << EOF
          from transformers import pipeline
          asr_pipeline = pipeline("automatic-speech-recognition", model="openai/whisper-base", device=0)
          result = asr_pipeline("output.mp3", return_timestamps=True)

          def format_timestamp(seconds):
              hours = int(seconds // 3600)
              minutes = int((seconds % 3600) // 60)
              seconds = seconds % 60
              milliseconds = int((seconds - int(seconds)) * 1000)
              return f"{hours:02}:{minutes:02}:{int(seconds):02},{milliseconds:03}"

          with open('transcript.srt', 'w', encoding='utf-8') as f:
              for i, segment in enumerate(result['chunks'], start=1):
                  start = segment['timestamp'][0]
                  end = segment['timestamp'][1]
                  text = segment['text'].strip()
                  f.write(f"{i}\n{format_timestamp(start)} --> {format_timestamp(end)}\n{text}\n\n")

          with open('transcript.txt', 'w', encoding='utf-8') as f:
              for segment in result['chunks']:
                  start = segment['timestamp'][0]
                  end = segment['timestamp'][1]
                  text = segment['text'].strip()
                  f.write(f"[{format_timestamp(start)} -> {format_timestamp(end)}] {text}\n")

          print("Transcription completed and saved.")
          EOF

      - name: Commit Transcript
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'
          git remote set-url origin https://${{ github.actor }}:${{ env.GH_TOKEN }}@github.com/${{ github.repository }}
          git add transcript.srt transcript.txt
          git commit -m 'Add transcription files'
          git push origin ${{ matrix.branch }}
